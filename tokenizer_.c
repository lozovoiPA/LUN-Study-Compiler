#include "compiler_globals.h"
#include "tokenizer_semantic_programs.h"
#include "tokenizer_.h"

// Задаем размеры массивов - таблицы переходов и семантических подпрограмм (ST_CH); и таблицы ASCII
// см. ниже какие массивы и для чего используются
#define ST_CH_H 10
#define ST_CH_W 23

// сокращение имени функции
#define state st_resolver

int chr_resolver(char);
int st_resolver(char);

// массивы индексов, которые мы будем использовать, заполняются через перекодировку исходных таблиц в функции st_ch_init()
char st_ch[ST_CH_H][ST_CH_W];
void (*st_pr[ST_CH_H][ST_CH_W])(char);
int chr_ind[ASCII_W];

char sts[] = "XFUSICDERP"; // Строка, чтобы вместо номера состояния вернуть его букву
char lex[] = " ak+-*/[](){},;z=<>"; // строка для вывода значения лексемы (только для состоящих из одного символа)

// Функция лексического анализатора
int tokenizer(char* str, int i){
    int st = state('S'), prv_st;
    for(; st != state('F') && !err_no && st != state('U'); i++){
        prv_st = st;
        st = st_ch[st][chr_ind[str[i]]]; // осуществляем переход, st - номер строки (номер текущего состояния), второе - номер столбца, вычисляется так: берется текущий символ и перекодируется в номер столбца в соответствии с таблицей перекодировки символов аскии в номера столбцов таблицы переходов.
        st_pr[prv_st][chr_ind[str[i]]](str[i]); // вызов подпрограммы. используется функция, хранящаяся в массиве такого же размера, что и таблица переходов, в ячейке с такими же номерами, как и при переходе.
        char_no++; // увеличиваем символ в строке на единицу
        //printf("%c %d\n", str[i], char_no); //если необходимо просмотреть процесс построения лексемы
    }
    // Обработка дополнительных действий особых конечных состояний
    if(st == state('U')){
        i--;
        char_no--; // т.к. этот же символ будем просмотрен второй раз
    }
    else if(err_no){
        prv_st = state('X');
    }
    _out_st = sts[prv_st];
    return i;
}

// Функция для вывода результатов лекс. анализатора
void tokenizer_output(){
    // Вывод состояния до конечного и номера лексемы
    printf(" %c %2d ", _out_st, _out_tk_no);
    // Вывод значения лексемы
    if(_out_tk_no == 2){
        if(_out_st == 'C'){
            printf("%d", n);
        }
        else{
            printf("%g", x);
        }
    }
    else if(_out_tk_no == 1 || _out_tk_no >= 19){
        printf("%s", name);
    }
    else {
        printf("%c", lex[_out_tk_no]);
    }
    printf("\n");
}

// функция инициализации лексического анализатора
void tokenizer_init(){
    allocate_resources();

    // таблица переходов
    char st_ch_chr[ST_CH_H][ST_CH_W] = {
        //         <err> <б>  <ц>  <.>   +    -    *    /    [    ]    (    )    {    }   < >   >    <    =    !    ;   \n   <\0>  ,
        /* err */ {},
        /* F */   {},
        /* U */   {},
        /* S */   { '-', 'I', 'C', '-', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'S', 'R', 'R', 'R', 'P', 'F', 'S', 'F', 'F' },
        /* I */   { '-', 'I', 'I', '-', 'U', 'U', 'U', 'U', 'U', 'U', 'U', 'U', 'U', '-', 'F', 'U', 'U', 'U', 'U', 'U', 'U', '-', 'U' },
        /* C */   { '-', '-', 'C', 'D', 'U', 'U', 'U', 'U', '-', 'U', '-', 'U', 'U', '-', 'F', 'U', 'U', 'U', 'U', 'U', 'U', '-', 'U' },
        /* D */   { '-', '-', 'E', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-' },
        /* E */   { '-', '-', 'E', '-', 'U', 'U', 'U', 'U', '-', 'U', '-', 'U', 'U', '-', 'F', 'U', 'U', 'U', 'U', 'U', 'U', '-', 'U' },
        /* R */   { '-', 'U', 'U', '-', 'U', 'U', '-', '-', '-', '-', 'U', '-', '-', '-', 'F', '-', '-', 'F', '-', '-', '-', '-', '-' },
        /* P */   { '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', '-', 'F', '-', '-', '-', '-', '-' }
    };

    // таблица номеров семантических подпрограмм
    int st_pr_ind[ST_CH_H][ST_CH_W] = {
        //         <err> <б>  <ц>  <.>   +    -    *    /    [    ]    (    )    {    }   < >   >    <    =    !    ;   \n   <\0>  ,
        /* err: */ {},
        /* F */    {},
        /* U */    {},
        /* S */    { -1,  1,   2,  -1,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,   1,   1,   1,   1,  15,  14,  17,  28 },
        /* I */    { -1, 18,  18,  -1,  19,  19,  19,  19,  19,  19,  19,  19,  19,  -1,  19,  19,  19,  19,  19,  19,  19,  -1,  19 },
        /* C */    { -1, -1,  20,  21,  22,  22,  22,  22,  -1,  22,  -1,  22,  22,  -1,  22,  22,  22,  22,  22,  22,  22,  -1,  22 },
        /* D */    { -1, -1,  23,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1 },
        /* E */    { -1, -1,  23,  -1,  22,  22,  22,  22,  -1,  22,  -1,  22,  22,  -1,  22,  22,  22,  22,  22,  22,  22,  -1,  22 },
        /* R */    { -1, 16,  16,  -1,  16,  16,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  16,  -1,  -1,  26,  -1,  -1,  -1,  -1,  -1 },
        /* P */    { -1, -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  26,  -1,  -1,  -1,  -1,  -1 }
    };
    // конвертация исходных таблиц (выше) в используемые лексическим анализатором массивы индексов
    for(int i = 0; i < ST_CH_H; i++){
        for(int j = 0; j < ST_CH_W; j++){
            st_ch[i][j] = st_resolver(st_ch_chr[i][j]);
            st_pr[i][j] = pr_resolver(st_pr_ind[i][j]);
        }
    }
    for(int i = 0; i < ASCII_W; i++){
        chr_ind[i] = chr_resolver((char)i);
    }
}

void tokenizer_dispose(){
    free_resources();
}

// функция перекодировки символов ASCII в индекс столбца матрицы переходов/семантических подпрограмм
int chr_resolver(char chr){
    if((chr >= 'A' && chr <= 'Z') ||
       (chr >= 'a' && chr <= 'z')){
        return 1;
    }
    if(chr >= '0' && chr <= '9'){
        return 2;
    }
    if(chr == '.'){
        return 3;
    }
    if(chr == '+'){
        return 4;
    }
    if(chr == '-'){
        return 5;
    }
    if(chr == '*'){
        return 6;
    }
    if(chr == '/'){
        return 7;
    }
    if(chr == '['){
        return 8;
    }
    if(chr == ']'){
        return 9;
    }
    if(chr == '('){
        return 10;
    }
    if(chr == ')'){
        return 11;
    }
    if(chr == '{'){
        return 12;
    }
    if(chr == '}'){
        return 13;
    }
    if(chr == ' '){
        return 14;
    }
    if(chr == '>'){
        return 15;
    }
    if(chr == '<'){
        return 16;
    }
    if(chr == '='){
        return 17;
    }
    if(chr == '!'){
        return 18;
    }
    if(chr == ';'){
        return 19;
    }
    if(chr == '\n'){
        return 20;
    }
    if(chr == '\0'){
        return 21;
    }
    if(chr == ','){
        return 22;
    }
    return 0;
}

// Функция перекодировки состояний в индекс строки матрицы переходов
int st_resolver(char st_chr) {
    switch (st_chr) {
        case 'F': return 1;  // Финальное состояние
        case 'U': return 2;  // Финальное состояние с дополнительным действием i -= 1
        case 'S': return 3;  // Начальное состояние
        case 'I': return 4;  // Встретилась буква
        case 'C': return 5;   // Встретилась цифра
        case 'D': return 6;   // Встретилась точка
        case 'E': return 7;   // Встретилась цифра после точки
        case 'R': return 8;   // Встретился знак сравнения/присваивания
        case 'P': return 9;   // Встретился '!'
        default:  return 0;  // Ошибка или нераспознанное состояние
    }
}
